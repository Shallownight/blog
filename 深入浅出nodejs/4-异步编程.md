# 深入浅出Node.js——异步编程
> 有异步I/O，必有异步编程。

## 1. 函数式编程
> 开始异步编程以前，先要知晓JavaScript先在的回调函数和深层嵌套的来龙去脉。

### 高阶函数
通常的语言中，函数参数只接受基本的数据类型或者是对象引用，返回值也是基本数据类型和对象引用。**而高阶函数可以把函数作为参数，或者将函数作为返回值**。  

调用和返回函数，形成了一种后续传递风格，它将函数的业务重点从返回值转移到了回调函数中。

### 偏函数
**偏函数：**通过指定部分参数来产生一个新的定制函数。  
解释：甲函数接收参数，返回一个函数。乙调用甲函数，并且传递某个参数给甲返回的函数，然后乙获得返回的函数。那么乙就是偏函数。  

## 2. 异步编程的优势和难点
### 优势
Node的最大特性：基于事件驱动的非阻塞I/O模型。  
CPU与I/O不互相依赖，让资源得到更好的利用。


利用事件循环方式，JavaScript线程就像一个分配任务和处理结果的大管家，I/O线程池里的各个I/O线程都是小二，负责兢兢业业的完成分配来的任务。

模型的缺点在于管家无法承担过多的细节性任务，如果承担太多，会影响到任务的调度。换而言之，Node更像一个处理I/O密集问题的能手,而CPU密集型则取决于管家的能耐如何。

### 难点
#### 异常处理
类JAVA的try/catch/final语句捕获异常不一定适用于异步编程。异步I/O的实现主要包括**提交请求**和**处理结果**，两者互不关联。异步方法通常在第一阶段提交请求后立即返回，而异常不一定发生在这个阶段，try/catch在此处不会发挥任何作用。

解决办法：在回调函数中用if语句判断是否error，如果有错误则return callback(error)，没错误则执行callback(null,result)。

#### 函数嵌套过深
代码难看，难以利用好异步I/O的优势。

#### 阻塞代码
通过写阻塞代码实现sleep()线程沉睡的功能。

	var start = new Date();
	while(new Date - start < 1000){
		//TODO
	}
但是这段代码会持续占用CPU进行判断，完全破坏事件循环的调度，导致奇遇任何请求都得不到响应。

解决办法：统一规划业务逻辑，调用setTimeout()。

#### 多线程编程
Node借鉴浏览器Web Workers的模式，让开发人员要更多的去面临跨线程编程。

#### 异步转同步
偶尔出现同步需求，但是没有同步API。

## 3. 异步编程解决方案
> 书中的内容难度突增，没有一定的Node开发经验很难理解，所以只简述，不详写。
### 事件发布/订阅模式

	//订阅
	emitter.on("event1",function(message){
		console.log(message);
	})
	//发布
	emitter.emit('event1',"i am message")
通过emit()发布事件后，消息会立即传递给当前事件的所有侦探器执行。

事件发布/订阅模式本身无同步和异步调用的问题，但在Node中,emit()调用多半是伴随事件循环而异步触发的。

### Promise/Deferred模式
http://www.cnblogs.com/lvdabao/p/es6-promise-1.html  

这篇文章对Promise讲解的很不错。

### 流程控制库

## 4. 异步并发控制
异步调用并发量太大的时候，服务器会吃不消，所以要控制并发。

以后要用的时候再查资料吧……